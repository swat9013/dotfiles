# Skill内サブエージェントオーケストレーション

skill/command内でTask toolを使ってサブエージェントを動的に起動するパターン集。

## 概要

### なぜskill内でadhocに呼び出すか

- **柔軟性**: タスクに応じて指示を調整可能
- **コンテキスト最適化**: 呼び出し時に必要な情報だけを渡す
- **管理コスト削減**: 別ファイルでの定義が不要

### コンテキスト設計

Claude Codeのコンテキスト設計は3層のみ:

| 層 | 用途 |
|----|------|
| CLAUDE.md | プロジェクト全体の方針 |
| rules/ | パス固有のガイドライン |
| skills/ | ワークフロー（サブエージェント呼び出し含む） |

---

## モデル選択ガイド

| タスク種別 | モデル | 特徴 | 例 |
|-----------|--------|------|-----|
| 軽量チェック | Haiku | 高速・低コスト | 前提条件チェック、ファイル検索 |
| 中程度の分析 | Sonnet | バランス型 | サマリー生成、コンプライアンスチェック |
| 複雑な判断 | Opus | 高精度 | バグ検出、セキュリティ分析、複雑な推論 |

---

## 段階的パイプラインパターン

```
┌─────────────┐
│ 1. 前処理   │ ← Haiku（条件チェック、対象特定）
└──────┬──────┘
       ↓
┌─────────────┐
│ 2. メイン処理│ ← Sonnet/Opus 並列実行
└──────┬──────┘
       ↓
┌─────────────┐
│ 3. 検証     │ ← サブエージェントで再検証
└──────┬──────┘
       ↓
┌─────────────┐
│ 4. フィルタ │ ← 検証されなかったものを破棄
└──────┬──────┘
       ↓
┌─────────────┐
│ 5. 出力     │ ← 高信号のみ報告
└─────────────┘
```

---

## 並列実行パターン

### 同じ観点を分割

```markdown
## Step 2: CLAUDE.mdコンプライアンスチェック

以下を**単一メッセージで並列起動**:

### Agent 1（Sonnet）
ファイル1-5のCLAUDE.mdコンプライアンスをチェック

### Agent 2（Sonnet）
ファイル6-10のCLAUDE.mdコンプライアンスをチェック
```

### 異なる観点を同時実行

```markdown
## Step 2: 並列レビュー

以下を**単一メッセージで並列起動**:

### Agent 1: CLAUDE.mdコンプライアンス（Sonnet x 2）
### Agent 2: バグ検出（Opus x 2）
```

重要: 「単一メッセージで」を明記することで、Claudeが複数のTask toolを1回のAPIコールで呼び出す。

---

## サブエージェント指示設計

### 必須要素

```markdown
Task tool:
- model: opus
- prompt: |
    ## ロール
    あなたはセキュリティ専門のレビュアーです。

    ## フォーカス範囲
    diffのみに集中。外部コンテキストは不要。

    ## フラグすべき
    - SQLインジェクション、XSS
    - 認証・認可の欠陥

    ## フラグしない
    - コードスタイル
    - 潜在的な問題
    - 確実でないもの

    ## 出力形式
    | ファイル | 行 | 種別 | 説明 |
```

### フォーカス範囲の明示

- 「diffのみに集中」
- 「外部コンテキストは不要」
- 「変更コード内のみを対象」

### ツール使用原則

```markdown
## 全エージェント共通ルール
- 全ツールは機能すると仮定（テスト呼び出し禁止）
- 探索的呼び出しは禁止（必要な場合のみ呼び出す）
- 各サブエージェントにも同じルールを周知
```

---

## 高信号フィルタリング

### フラグすべき

- コンパイル/パースエラー
- 型エラー、missing imports
- 明白なロジックエラー
- 明確なルール違反（引用可能）

### フラグしない（偽陽性回避）

- コードスタイルの懸念
- 入力依存の潜在的問題
- 主観的な改善提案
- 確実でない問題
- 既存の問題（新規導入ではない）
- ベテランエンジニアがフラグしない細部
- Linterがcatchする問題

---

## 検証サブエージェント

検出されたissueを別エージェントで再検証:

```markdown
## Step 3: 検証

Step 2で検出された各issueに対して:
- 並列でサブエージェントを起動
- バグ: Opus、CLAUDE.md違反: Sonnet
- issueの妥当性を検証
- 検証されなかったissueは破棄
```

---

## サブエージェントへのルール継承

```markdown
## サブエージェント呼び出し時
親エージェントのルールをサブエージェントにも周知:
- 共通原則をプロンプトに含める
- 出力形式を統一
- フラグ基準を継承
```

---

## 出力形式の標準化

### リンク形式

```
形式: https://github.com/owner/repo/blob/[FULL_SHA]/path#L[start]-L[end]

要件:
- フルgit SHA必須（短縮形NG）
- 行範囲: L[start]-L[end]
- コンテキスト: 対象行の前後1行以上を含める
```

### コメント形式

- 小規模（6行以下）: 修正提案を含める
- 大規模（6行以上）: 説明のみ
- 1 issue = 1 comment（重複禁止）

---

## 実例: code-review.mdパターン

Claude Code公式のcode-review.mdの構造:

```markdown
## Step 1: 前処理チェック（Haiku）
PRがクローズ済み/ドラフト/レビュー不要かをチェック

## Step 2: CLAUDE.md検索（Haiku）
関連するCLAUDE.mdファイルのパスを取得

## Step 3: PRサマリー（Sonnet）
PR全体の変更サマリーを取得

## Step 4: 並列レビュー
- Agent 1 & 2: CLAUDE.mdコンプライアンス（Sonnet x 2）
- Agent 3 & 4: バグ検出（Opus x 2）

## Step 5: 検証
各issueをサブエージェントで再検証

## Step 6: フィルタリング
検証されなかったissueを削除

## Step 7: 出力
高信号issueのみをインラインコメントで投稿
```
