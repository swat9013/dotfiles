---
name: troubleshooting
description: >-
  バグ調査・トラブルシュートの専門ワークフロー。問題の切り分けから根本原因特定まで仮説駆動で検証し、
  即時修正か仕様・設計の見直しかを判定する。「デバッグ」「バグ調査」「エラー解析」「原因調査」
  「不具合」「動かない」「エラーが出る」「トラブルシュート」と依頼された時に使用。
argument-hint: "[エラーメッセージ、症状、またはログファイルパス]"
disable-model-invocation: true
---

# Troubleshooting

バグ調査・トラブルシュートを支援し、根本原因の特定と修正案を提示する。
問題を切り分け、即時修正か仕様・設計の見直しかを判定し、根本的改善へ導く。

## 使用方法

```
/troubleshooting TypeError: Cannot read property 'x' of undefined
/troubleshooting ログイン後にセッションが切れる問題
/troubleshooting logs/error.log
```

## Phase 1: 状況把握と切り分け

**対話形式**で情報を収集する。推測で埋めない。

`$ARGUMENTS` が提供されている場合:
1. エラーメッセージ/スタックトレースを分析
2. 不足情報を特定し、以下の優先順で1つ質問する:
   - 再現手順（いつ・どの操作で発生するか）
   - 発生頻度（常時 / 間欠 / 特定条件）
   - 最近の変更（直前のデプロイ・コード変更）

`$ARGUMENTS` が空の場合:
「どのようなエラーや症状が発生していますか?（エラーメッセージ、スタックトレース、症状の説明）」

不明点は `[NEEDS CLARIFICATION: 質問]` を挿入（最大3箇所）。

**問題の切り分け**:
1. 影響範囲を特定: どのコンポーネント/レイヤーで発生しているか
2. 分割統治で絞り込み:
   - コード空間: 半分ずつ無効化して再現するか確認
   - 時間軸: `git bisect` で問題導入コミットを特定
   - 入力空間: 入力を最小化し再現条件を探す
3. 切り分け結果を記録（何を試し、何が判明したか）

詳細な分割統治パターンは `references/debugging-principles.md` を参照。

## Phase 2: 仮説立案と検証

根本原因の特定は ultrathink で論理を丁寧に追う。

**仮説検証ループ**（5 Whys で深掘りしながら各層を検証）:
1. 収集した情報から仮説を立てる
2. **反証テストを先に実行**: 仮説が正しければ起こりえない現象を探す
3. 下記ツールで仮説を検証する調査を実行
4. 結果に基づいて仮説を更新または棄却
5. 根本原因が特定されるまで繰り返す

**5 Whys で深掘り**（各 Why を上記ループで検証する）:
1. なぜエラーが発生した? → 直接原因 (証拠: [ログ/コード参照])
2. なぜその直接原因が存在した? (証拠: [...])
3. なぜ...（根本原因に到達するまで繰り返す）

各 Why の回答は、検証済みの事実に基づくこと。証拠なきWhyは推測の連鎖を生む。

**アプローチ固着の回避**: 同じツール/手法で3回進展なし → 手法を切り替える。
構造化された仮説フォーマットと認知バイアス対策は `references/debugging-principles.md` を参照。

**調査ツールの選択**:

| 調査目的 | ツール | 使い方 |
|---------|--------|--------|
| エラーメッセージ検索 | Grep | パターンでコードベース横断検索 |
| スタックトレース追跡 | Read | 該当ファイルの前後を読む |
| 最近の変更確認 | Bash (`git log`/`blame`) | 問題箇所の変更履歴 |
| プロセス/ポート確認 | Bash (`lsof -a`, `ps`) | ランタイム状態調査 |
| シンボル参照追跡 | Serena MCP | 大規模コードベースでの影響範囲調査 |
| UI/表示問題 | agent-browser / playwright-cli | ブラウザ上の確認・再現 |

詳細な調査パターンは `references/tool-strategies.md` を参照。

**ログが不足している場合**:
仮説検証に必要な最小限のDEBUGログを一時追加し、修正完了後に除去。
恒久的なログ改善が必要な場合は log-designing スキルを参照。

**調査中の専門スキル委譲**（調査に別の専門性が必要な場合）:

| 状況 | 参照先 |
|------|--------|
| ログ不足・ログ設計見直し | log-designing スキル |
| UI/表示問題の再現 | playwright-cli / agent-browser スキル |
| 大規模コードのシンボル追跡 | serena スキル |

## Phase 3: 対応判定

**Q1: 原因を理解したか?**
- No → Phase 2 に戻る（理解なき修正は禁止）

**Q2: 即時修正が可能かつ妥当か?**

| 判定 | 条件 | 対応 |
|------|------|------|
| 即時修正 | コードのバグ（タイポ、null未チェック、ロジックミス） | 修正 + テスト追加 + 再現確認 |
| 仕様・前提の見直し | 仕様の誤解、設計前提の崩壊、要件の矛盾 | `/requirements` or `/architect` へエスカレーション |
| 応急処置 + 根本対応 | 即時対応が必要だが根本原因は設計にある | 応急パッチ + 根本対応を TODO/Issue に起票 |

**エスカレーション判定基準**（以下に該当 → 即時修正ではなく見直し/応急+根本を選択）:
- 同箇所で過去にも類似バグ / 修正が3ファイル以上に波及 → 設計見直しの兆候
- 「なぜこの仕様なのか」説明不能 → 前提の見直し

**エスカレーション先**: `/discovery`（問題定義見直し）/ `/requirements`（要件再定義）/ `/architect`（再設計）

修正後、必ず再現手順で問題が解消されたことを確認する。

## Phase 4: 結果出力

テンプレート `templates/debug-report.md` を使用してデバッグレポートを作成。

**再発防止の検討**:
- この種のバグは他箇所にも潜在していないか? → 横展開チェック
- テスト・lintルール・型制約で自動検出できないか? → 予防策の提案
- ログ/監視が不足していたなら → log-designing スキルへ

## 成功基準

1. 直接原因と根本原因が明確に区別して特定されている
2. 修正案が具体的（ファイル名、行番号、コード例を含む）
3. 対応判定が根拠付きで行われている（即時修正 / 見直し / 応急+根本）

## 完了チェックリスト

- [ ] 問題の影響範囲を特定した
- [ ] 直接原因と根本原因を証拠付きで区別した
- [ ] 仮説を検証してから修正した（推測で修正していない）
- [ ] 対応判定を行った（即時修正 / 仕様見直し / 応急+根本対応）
- [ ] 修正案が具体的（ファイル名、行番号、コード例）
- [ ] テスト追加案を含めた
- [ ] 再発防止策を検討した

## 原則

- **切り分けファースト**: 仮説の前に問題の範囲を狭める
- **仮説駆動**: 推測で修正しない、仮説を立てて反証から検証する
- **証拠付き5 Whys**: 各Whyに証拠を紐づける。証拠なきWhyは推測の連鎖
- **理解してから修正**: 「なぜこの修正で直るか」を説明できるまで適用しない
- **修正か見直しか判断**: 応急処置で終わらせず、根本的改善へ導く
