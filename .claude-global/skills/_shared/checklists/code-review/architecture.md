# アーキテクチャレビューチェックリスト

## スコープ

レイヤー分離、依存方向、結合度、契約による設計など、設計原則の遵守を検証。長期的な保守性と拡張性を重視。

---

## High

### アーキテクチャ
- [ ] レイヤー分離の遵守
- [ ] 依存の方向が正しい（上位→下位のみ）
- [ ] 循環依存がない

### 結合度・コナーセンス
- [ ] 強い結合（内容結合・共通結合）がないか
- [ ] 動的コナーセンス（実行順序・タイミング・値・同一性）が最小限か
- [ ] 境界を越える結合は弱い形式（データ結合・名前のコナーセンス）か

### 契約による設計と信頼境界線
- [ ] 信頼境界線が明確に定義されている（外部入力、API境界、モジュール境界）
- [ ] 境界上でのみバリデーション・サニタイズを実施（内部では信頼）
- [ ] 事前条件・事後条件・不変条件が適切に定義されている
- [ ] 防御的コードが境界に集中し、内部ロジックは簡潔か

## Medium

### 構造設計（KISS/DRY/SLAP/SRP）
- [ ] 最もシンプルな解決策になっている
- [ ] 同じ責務を持つコードが一箇所にまとまっている
- [ ] 1関数内が同じ抽象レベルで記述されている
- [ ] 1クラス/モジュールが1つの責任のみ持つ

---

## 用語定義

### レイヤー構成（クリーンアーキテクチャ例）

| レイヤー | 責務 | 依存方向 |
|----------|------|----------|
| Presentation | UI、APIエンドポイント | → Application |
| Application | ユースケース | → Domain |
| Domain | ビジネスルール | 依存なし（中心） |
| Infrastructure | 外部連携 | → Domain |

**原則**: 外側→内側のみ依存。Domain は何にも依存しない。

### 境界の種類

| 境界 | 越える際のルール |
|------|------------------|
| モジュール境界 | 名前のコナーセンス（CoN）で十分 |
| パッケージ境界 | インターフェース経由を推奨 |
| レイヤー境界 | 依存逆転、データ結合を徹底 |
| サービス境界 | API契約、冪等性が必須 |

### 結合度（弱い順）

| 種類 | 問題度 |
|------|--------|
| データ結合（プリミティブのみ渡す） | 最良 |
| スタンプ結合（複合データの一部使用） | 軽度 |
| 制御結合（フラグで振る舞い変更） | 中度 |
| 共通結合（グローバル状態共有） | 高度 |
| 内容結合（内部を直接参照） | 最悪 |

### コナーセンス

**静的**（弱い順）: 名前(CoN) → 型(CoT) → 意味(CoM) → 位置(CoP) → アルゴリズム(CoA)

**動的**（より強い）: 実行順序(CoE) → タイミング(CoTm) → 値(CoV) → 同一性(CoI)

**評価軸**: 強度（強いほど困難）、局所性（遠いほど問題）、程度（広いほど問題）

### 抽象レベル（SLAP）

| レベル | 特徴 | 例 |
|--------|------|-----|
| 高 | 「何をするか」 | validateOrder(), sendNotification() |
| 中 | ビジネスルール | if (order.total > limit) |
| 低 | 技術的詳細 | db.query(), JSON.parse() |

**原則**: 1関数内では同じ抽象度の処理のみ記述。混在していたら分離。
