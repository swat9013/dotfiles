# レビュー判定基準

## TOC

1. [Architecture](#architecture)
2. [Test Strategy](#test-strategy)
3. [API Design](#api-design)
4. [Behavior](#behavior)
5. [高信号フィルタ](#高信号フィルタ)

## Architecture

### チェック項目

- **責務分離**: 1モジュール/クラスが単一責務を持つか
- **依存方向**: 上位層→下位層の一方向か。循環依存がないか
- **抽象レベル**: 同一関数内の文が同じ抽象レベルか（SLAP）
- **結合度**: モジュール間の結合が最小限か。変更波及範囲は限定的か
- **CLAUDE.md/rules 準拠**: プロジェクト固有の構造ルールに従っているか

### フラグ基準

- 循環依存の導入
- 責務の混在（UIロジックとビジネスロジックの同居等）
- レイヤー違反（ドメイン層からインフラ層への直接依存等）
- プロジェクト規約への明確な違反

## Test Strategy

### チェック項目

- **カバレッジ**: 主要パス（正常系・異常系）がテストされているか
- **テスト粒度**: ユニット/統合/E2Eの適切な使い分け
- **テスト品質**: テストが仕様を表現しているか（What）
- **境界値**: エッジケース・境界条件のテスト有無
- **モック適切性**: 外部依存のモックが適切か。過剰モックでないか

### フラグ基準

- 重要なビジネスロジックのテスト欠落
- テストが実装詳細に依存（リファクタリングで壊れる）
- 境界値テストの欠落（off-by-one等のリスク）
- 非決定的テスト（時刻依存、順序依存）

## API Design

### チェック項目

- **契約の明確さ**: 入出力の型・制約が明確か
- **一貫性**: 命名・パターンが既存APIと統一されているか
- **エラー設計**: エラーケースが明示的に定義されているか
- **後方互換性**: 既存の呼び出し元を破壊しないか
- **冪等性**: 必要な操作が冪等か

### フラグ基準

- 戻り値型の不整合（宣言と実装の乖離）
- 暗黙のnull/undefined返却
- エラーの握りつぶし（catch内の空処理）
- 既存API呼び出し元への破壊的変更

## Behavior

### チェック項目

- **正確性**: ロジックが仕様通りに動作するか
- **エッジケース**: 空配列、null、0、空文字列等の処理
- **並行性**: 競合状態・デッドロックのリスク
- **リソース管理**: メモリリーク、ファイルハンドルリーク
- **セキュリティ**: インジェクション、XSS、認証/認可の欠陥

### フラグ基準

- 明確なロジックエラー（条件の反転、off-by-one）
- セキュリティ脆弱性（SQLインジェクション、XSS、パストラバーサル）
- リソースリーク（close/dispose の欠落）
- 未処理の例外パス

## 高信号フィルタ

### フラグすべき（高信号）

| カテゴリ | 例 |
|---------|-----|
| コンパイル/パースエラー | 構文エラー、型エラー |
| ロジックエラー | 条件反転、無限ループ、off-by-one |
| セキュリティ脆弱性 | SQLi、XSS、認証バイパス |
| 規約違反 | CLAUDE.md/rules の明確な違反 |
| テスト欠落 | 重要パスのカバレッジ欠落 |
| API契約違反 | 型不整合、破壊的変更 |

### フラグしない（低信号）

| カテゴリ | 理由 |
|---------|------|
| コードスタイル | Linter管轄 |
| 命名の好み | 主観的 |
| 潜在的問題 | 入力依存の仮定で確度が低い |
| 既存コードの問題 | 新規導入ではない（スコープ外） |
| パフォーマンス推測 | 計測なしの最適化提案 |
